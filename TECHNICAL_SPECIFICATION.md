# Техническое задание: МИСКА РИС

## Общее описание

Система предназначена для мониторинга запретных зон с помощью веб-камеры. При обнаружении человека в запретной зоне формируется уведомление, которое отправляется на зарегистрированные Android-устройства сотрудников. Система работает исключительно в локальной сети (WiFi/LAN), без доступа в интернет.

## Компоненты системы

1. **Серверная часть** - обработка видео, детекция людей, управление зонами, отправка уведомлений
2. **Веб-интерфейс** - управление системой, просмотр потока, настройка зон, просмотр логов
3. **Android-приложение** - получение уведомлений, подтверждение/отклонение нарушений

---

## Этап 1: Архитектура и инфраструктура проекта

### Цель
Определить технологический стек, структуру проекта и базовую инфраструктуру.

### Задачи
- [ ] Выбрать технологический стек:
  - Сервер: Python (Flask/FastAPI)
  - Детекция: YOLO/OpenCV/MediaPipe
  - База данных: SQLite (для локальной работы)
  - Веб-интерфейс: HTML/CSS/JavaScript
  - Android: Kotlin/Java
- [ ] Создать структуру директорий проекта
- [ ] Настроить виртуальное окружение Python
- [ ] Создать requirements.txt с базовыми зависимостями
- [ ] Создать README.md с описанием проекта
- [ ] Определить формат конфигурационных файлов

### Результат
Готовая структура проекта, настроенное окружение, документация по архитектуре.

---

## Этап 2: Базовый веб-сервер и API

### Цель
Создать базовый веб-сервер с API для взаимодействия компонентов системы.

### Задачи
- [ ] Настроить веб-сервер (Flask/FastAPI)
- [ ] Реализовать CORS для работы с локальной сетью
- [ ] Создать базовую структуру API endpoints:
  - `/api/status` - статус сервера
  - `/api/register` - регистрация Android-клиента
  - `/api/unregister` - отмена регистрации клиента
  - `/api/clients` - список зарегистрированных клиентов
- [ ] Настроить статическую раздачу файлов для веб-интерфейса
- [ ] Реализовать базовую обработку ошибок

### Результат
Работающий веб-сервер с базовым API, доступный в локальной сети.

---

## Этап 3: Работа с видеопотоком

### Цель
Реализовать захват видео с веб-камеры и возможность работы с видеофайлами.

### Задачи
- [ ] Реализовать класс для работы с веб-камерой (OpenCV)
- [ ] Реализовать класс для работы с видеофайлами
- [ ] Создать API endpoint для получения видеопотока:
  - `/api/video/stream` - поток с камеры (MJPEG)
  - `/api/video/upload` - загрузка видеофайла для тестирования
  - `/api/video/control` - управление воспроизведением (play/pause/stop)
- [ ] Реализовать переключение между камерой и файлом
- [ ] Добавить обработку ошибок (камера недоступна, файл не найден)

### Результат
Функциональный видеопоток, доступный через API, с возможностью переключения между камерой и файлом.

---

## Этап 4: Детекция людей

### Цель
Интегрировать нейросеть для детекции людей в кадре.

### Задачи
- [ ] Выбрать модель детекции (YOLO v8/v5, MediaPipe, или другая)
- [ ] Реализовать класс детектора людей
- [ ] Добавить поддержку нескольких моделей (выбор через конфигурацию)
- [ ] Реализовать предобработку кадров
- [ ] Реализовать постобработку результатов детекции
- [ ] Создать API endpoint:
  - `/api/models` - список доступных моделей
  - `/api/models/current` - текущая модель
  - `/api/models/set` - установка модели
- [ ] Оптимизировать производительность (GPU/CPU)

### Результат
Работающая детекция людей в видеопотоке с возможностью выбора модели.

---

## Этап 5: Управление запретными зонами

### Цель
Реализовать создание, редактирование и удаление запретных зон.

### Задачи
- [ ] Определить формат хранения зон (JSON/SQLite)
- [ ] Реализовать класс для работы с зонами (полигоны/прямоугольники)
- [ ] Реализовать проверку попадания точки в зону
- [ ] Создать API endpoints:
  - `/api/zones` - список всех зон (GET), создание зоны (POST)
  - `/api/zones/<id>` - получение (GET), обновление (PUT), удаление (DELETE) зоны
- [ ] Реализовать валидацию зон (минимум 3 точки для полигона)
- [ ] Добавить возможность именования зон

### Результат
API для управления запретными зонами с сохранением в БД/файл.

---

## Этап 6: Определение нарушений и формирование уведомлений

### Цель
Реализовать логику определения нарушений и формирование уведомлений.

### Задачи
- [ ] Интегрировать детекцию людей с проверкой зон
- [ ] Реализовать алгоритм определения попадания человека в зону:
  - Проверка центра масс детекции
  - Проверка пересечения bounding box с зоной
- [ ] Реализовать дебаунсинг (избежание множественных срабатываний)
- [ ] Реализовать сохранение фотографии события
- [ ] Создать структуру уведомления:
  - Время нарушения (timestamp)
  - Путь к фотографии
  - ID зоны
  - Координаты нарушения
- [ ] Реализовать очередь уведомлений
- [ ] Создать API endpoint:
  - `/api/violations` - список нарушений
  - `/api/violations/<id>/image` - получение изображения нарушения

### Результат
Работающая система определения нарушений с формированием уведомлений.

---

## Этап 7: Система уведомлений для Android-клиентов

### Цель
Реализовать отправку уведомлений на зарегистрированные Android-устройства.

### Задачи
- [ ] Реализовать хранение списка зарегистрированных клиентов
- [ ] Выбрать протокол уведомлений:
  - WebSocket для real-time уведомлений
  - HTTP long polling
  - Server-Sent Events (SSE)
- [ ] Реализовать отправку уведомлений:
  - Формат JSON с данными нарушения
  - Отправка изображения (base64 или URL)
- [ ] Реализовать обработку ответов от клиентов (ДА/НЕТ)
- [ ] Создать API endpoints:
  - `/api/notifications/send` - отправка уведомления
  - `/api/notifications/response` - получение ответа от клиента
- [ ] Реализовать таймауты для неотвеченных уведомлений

### Результат
Работающая система отправки уведомлений на Android-устройства с получением ответов.

---

## Этап 8: Система логирования

### Цель
Реализовать сохранение всех событий системы в логи.

### Задачи
- [ ] Спроектировать схему базы данных для логов:
  - Таблица нарушений (violations)
  - Таблица ответов операторов (operator_responses)
  - Таблица системных событий (system_events)
- [ ] Реализовать класс для работы с логами
- [ ] Реализовать сохранение:
  - Время события
  - Фотография события
  - ID зоны
  - Статус (ожидает ответа, подтверждено, ложное срабатывание)
  - Ответ оператора (если есть)
  - ID оператора (если есть)
- [ ] Реализовать экспорт логов (CSV/JSON)
- [ ] Создать API endpoints:
  - `/api/logs` - получение логов с фильтрацией и пагинацией
  - `/api/logs/export` - экспорт логов
  - `/api/logs/stats` - статистика по нарушениям

### Результат
Полноценная система логирования всех событий с возможностью просмотра и экспорта.

---

## Этап 9: Веб-интерфейс - основной поток и управление

### Цель
Создать веб-интерфейс для отображения видеопотока и базового управления.

### Задачи
- [ ] Создать HTML-страницу с основным интерфейсом
- [ ] Реализовать отображение видеопотока:
  - MJPEG stream или WebSocket для видео
  - Элементы управления (переключение камера/файл)
- [ ] Реализовать загрузку видеофайла:
  - Drag & drop или file input
  - Элементы управления воспроизведением (play/pause/stop)
  - Отображение прогресса воспроизведения
- [ ] Реализовать выбор модели детекции:
  - Выпадающий список доступных моделей
  - Отображение текущей модели
  - Индикатор загрузки при смене модели
- [ ] Добавить навигацию (ссылка на страницу логов)
- [ ] Реализовать адаптивный дизайн

### Результат
Работающий веб-интерфейс с отображением видеопотока и базовым управлением.

---

## Этап 10: Веб-интерфейс - управление зонами

### Цель
Реализовать визуальное создание и редактирование запретных зон.

### Задачи
- [ ] Интегрировать canvas или библиотеку для рисования поверх видео
- [ ] Реализовать режим редактирования зон:
  - Создание новой зоны (рисование полигона)
  - Редактирование существующей зоны (перетаскивание точек)
  - Удаление зоны
- [ ] Реализовать отображение существующих зон поверх видео
- [ ] Реализовать список зон с возможностью:
  - Выделения зоны на видео
  - Переименования
  - Удаления
- [ ] Добавить валидацию (минимум точек, закрытый полигон)
- [ ] Реализовать сохранение зон через API
- [ ] Добавить визуальную обратную связь (подсветка активной зоны)

### Результат
Полнофункциональный редактор зон с визуальным интерфейсом.

---

## Этап 11: Веб-интерфейс - страница логов

### Цель
Создать страницу для просмотра и анализа логов системы.

### Задачи
- [ ] Создать HTML-страницу для логов
- [ ] Реализовать таблицу с логами:
  - Время события
  - Миниатюра фотографии
  - Название зоны
  - Статус (ожидает/подтверждено/ложное)
  - Ответ оператора
- [ ] Реализовать фильтрацию:
  - По дате
  - По статусу
  - По зоне
- [ ] Реализовать пагинацию
- [ ] Реализовать просмотр полного изображения события (модальное окно)
- [ ] Добавить статистику:
  - Общее количество нарушений
  - Подтверждённые/ложные срабатывания
  - График нарушений по времени
- [ ] Реализовать экспорт логов (кнопка скачивания)

### Результат
Полнофункциональная страница просмотра логов с фильтрацией и статистикой.

---

## Этап 12: Android-приложение - базовая структура

### Цель
Создать базовую структуру Android-приложения.

### Задачи
- [ ] Создать проект Android (Kotlin/Java)
- [ ] Настроить минимальные разрешения:
  - INTERNET (для локальной сети)
  - POST_NOTIFICATIONS (для уведомлений)
- [ ] Создать базовую структуру приложения:
  - MainActivity
  - Сервис для фоновой работы
  - Модели данных (Violation, Notification)
- [ ] Настроить зависимости (Retrofit, Gson, WebSocket клиент)
- [ ] Создать базовый UI (активности, фрагменты)
- [ ] Реализовать навигацию между экранами

### Результат
Базовая структура Android-приложения готова к разработке функционала.

---

## Этап 13: Android-приложение - регистрация на сервере

### Цель
Реализовать подключение приложения к серверу и регистрацию.

### Задачи
- [ ] Создать экран настроек:
  - Поле ввода IP-адреса сервера
  - Поле ввода порта (опционально)
  - Кнопка подключения
- [ ] Реализовать API-клиент для взаимодействия с сервером:
  - Регистрация (`/api/register`)
  - Отмена регистрации (`/api/unregister`)
- [ ] Реализовать сохранение настроек (SharedPreferences)
- [ ] Реализовать индикацию статуса подключения:
  - Подключение...
  - Подключено
  - Ошибка подключения
- [ ] Реализовать автоматическое переподключение при потере связи
- [ ] Добавить обработку ошибок (неверный IP, сервер недоступен)

### Результат
Приложение может подключаться к серверу и регистрироваться для получения уведомлений.

---

## Этап 14: Android-приложение - получение уведомлений

### Цель
Реализовать получение и отображение уведомлений о нарушениях.

### Задачи
- [ ] Реализовать подключение к серверу уведомлений (WebSocket/SSE/Long Polling)
- [ ] Реализовать парсинг уведомлений (JSON)
- [ ] Реализовать загрузку изображения нарушения:
  - Из base64 или по URL
  - Кэширование изображений
- [ ] Создать экран уведомления:
  - Отображение фотографии события
  - Отображение времени события
  - Кнопки "ДА" и "НЕТ"
- [ ] Реализовать системные уведомления (NotificationManager):
  - Показ уведомления в статус-баре
  - Открытие экрана при нажатии
- [ ] Реализовать очередь уведомлений (если приходит несколько)
- [ ] Добавить звуковое/вибро оповещение

### Результат
Приложение получает и отображает уведомления о нарушениях.

---

## Этап 15: Android-приложение - отправка ответа оператора

### Цель
Реализовать отправку ответа оператора на сервер.

### Задачи
- [ ] Реализовать обработку нажатий кнопок "ДА" и "НЕТ"
- [ ] Реализовать отправку ответа через API (`/api/notifications/response`)
- [ ] Реализовать структуру ответа:
  - ID уведомления
  - Ответ оператора (true/false)
  - Время ответа
- [ ] Добавить индикацию отправки ответа
- [ ] Реализовать обработку ошибок отправки (повторная попытка)
- [ ] Реализовать закрытие экрана уведомления после отправки
- [ ] Добавить подтверждение отправки (toast/диалог)

### Результат
Приложение отправляет ответы оператора на сервер и обрабатывает результат.

---

## Этап 16: Интеграция и тестирование

### Цель
Протестировать всю систему в комплексе и устранить ошибки.

### Задачи
- [ ] Интеграционное тестирование:
  - Тест полного цикла: нарушение → уведомление → ответ
  - Тест работы с несколькими клиентами
  - Тест обработки отключения клиента
- [ ] Тестирование производительности:
  - Нагрузка на сервер при нескольких клиентах
  - Оптимизация детекции
  - Оптимизация передачи изображений
- [ ] Тестирование в локальной сети:
  - Проверка работы через WiFi
  - Проверка работы через LAN
  - Проверка стабильности соединения
- [ ] Тестирование граничных случаев:
  - Камера недоступна
  - Файл не найден
  - Нет зарегистрированных клиентов
  - Сервер перезагружается
- [ ] Исправление найденных ошибок
- [ ] Оптимизация кода
- [ ] Финальная документация

### Результат
Полностью рабочая и протестированная система, готовая к использованию.

---

## Дополнительные требования

### Безопасность
- Все соединения только в локальной сети
- Валидация всех входных данных
- Обработка ошибок на всех уровнях

### Производительность
- Оптимизация детекции (возможность снижения FPS для экономии ресурсов)
- Сжатие изображений перед отправкой
- Кэширование на клиенте

### Удобство использования
- Интуитивный интерфейс
- Понятные сообщения об ошибках
- Логирование для отладки

---

## Технологический стек (рекомендации)

### Серверная часть
- **Python 3.8+**
- **Flask/FastAPI** - веб-фреймворк
- **OpenCV** - работа с видео
- **YOLO/MediaPipe** - детекция людей
- **SQLite** - база данных
- **WebSocket/SSE** - уведомления в реальном времени

### Веб-интерфейс
- **HTML5/CSS3/JavaScript**
- **Canvas API** - рисование зон
- **Fetch API/WebSocket** - взаимодействие с сервером

### Android-приложение
- **Kotlin/Java**
- **Retrofit** - HTTP-клиент
- **WebSocket клиент** - получение уведомлений
- **Glide/Picasso** - загрузка изображений
- **Material Design** - UI компоненты

---

## Порядок выполнения этапов

Этапы рекомендуется выполнять в указанном порядке, так как каждый последующий этап зависит от предыдущих. Однако некоторые этапы можно выполнять параллельно:

- **Этапы 9-11** (веб-интерфейс) можно разрабатывать параллельно после завершения этапов 2-7
- **Этапы 12-15** (Android) можно разрабатывать параллельно с веб-интерфейсом после завершения этапов 2, 6, 7

---

## Критерии готовности этапа

Каждый этап считается завершённым, когда:
1. Реализованы все задачи этапа
2. Код протестирован и работает
3. Нет критических ошибок
4. Код задокументирован (комментарии, docstrings)

